// Smooth velocity with easing
function updateMouse(time){
  const box = getBoxRect();
  const fleeDist = 700;
  const personalSpace = 400;
  const maxSpeed = 9;
  const borderRepulsion = 150;
  const minVelocity = 1.5;

  let dx = mouse.x - cat.x;
  let dy = mouse.y - cat.y;
  let dist = Math.hypot(dx,dy);
  let ax=0, ay=0;

  // Flee cat with easing
  if(dist<fleeDist && dist>0){
    let strength = Math.pow((fleeDist-dist)/fleeDist,2)*15;
    ax += (dx/dist)*strength;
    ay += (dy/dist)*strength;
  }

  // Personal space (gentle push)
  if(dist<personalSpace && dist>0){
    ax += (dx/dist)*(personalSpace-dist)*0.5;
    ay += (dy/dist)*(personalSpace-dist)*0.5;
  }

  // Zigzag / curved movement using sin + noise
  if(dist>0){
    const perpX = -dy/dist;
    const perpY = dx/dist;
    const amp = 2 + Math.random()*2; // lower amplitude for smoother
    const freq = 0.01 + Math.random()*0.01; // vary frequency slightly
    ax += perpX * Math.sin(time*freq)*amp;
    ay += perpY * Math.cos(time*freq)*amp;
  }

  // Border repulsion (soft)
  const k = 0.05;
  if(mouse.x<borderRepulsion) ax += (borderRepulsion-mouse.x)*k;
  if(mouse.x>canvas.width-borderRepulsion) ax -= (mouse.x-(canvas.width-borderRepulsion))*k;
  if(mouse.y<borderRepulsion) ay += (borderRepulsion-mouse.y)*k;
  if(mouse.y>canvas.height-borderRepulsion) ay -= (mouse.y-(canvas.height-borderRepulsion))*k;

  // GitHub box soft repulsion
  if(mouse.x>box.x && mouse.x<box.x+box.width && mouse.y>box.y && mouse.y<box.y+box.height){
    const cx = box.x+box.width/2;
    const cy = box.y+box.height/2;
    const bx = mouse.x-cx;
    const by = mouse.y-cy;
    const d = Math.hypot(bx,by);
    if(d>0){
      let rep = 4; // softer repulsion
      ax += (bx/d)*rep;
      ay += (by/d)*rep;
    }
  }

  // Center attraction (very gentle)
  const centerX = canvas.width/2;
  const centerY = canvas.height/2;
  ax += (centerX - mouse.x)*0.08;
  ay += (centerY - mouse.y)*0.08;

  // Smooth velocity blending
  mouse.vx += (ax - mouse.vx) * 0.08; // easing factor
  mouse.vy += (ay - mouse.vy) * 0.08;

  // Speed limit
  let speed = Math.hypot(mouse.vx, mouse.vy);
  if(speed>maxSpeed){
    mouse.vx = (mouse.vx/speed)*maxSpeed;
    mouse.vy = (mouse.vy/speed)*maxSpeed;
  }

  // Minimal random twitch to avoid mechanical stillness
  if(speed<minVelocity){
    let angle = Math.random()*2*Math.PI;
    mouse.vx += Math.cos(angle)*0.3;
    mouse.vy += Math.sin(angle)*0.3;
  }

  mouse.x += mouse.vx;
  mouse.y += mouse.vy;
}
