<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cat and Mouse Bouncing Chase</title>
<style>
  body { margin:0; overflow:hidden; background:#ffeedd; cursor:default; font-family:Arial,sans-serif; }
  canvas { display:block; }
  #githubBox {
    position:absolute; bottom:20px; right:20px;
    width:300px; padding:10px; background:rgba(255,255,255,0.9);
    border-radius:10px; box-shadow:0 0 10px rgba(0,0,0,0.3);
  }
  #githubBox h3 { margin:0 0 5px 0; font-size:16px; color:#333; }
  #githubBox a { display:block; font-size:14px; color:#0066cc; text-decoration:none; margin-bottom:5px; }
  #githubBox a:hover { text-decoration:underline; }
</style>
</head>
<body>
<canvas id="catCanvas"></canvas>

<div id="githubBox">
  <h3>My GitHub Projects:</h3>
  <a href="https://github.com/FlorianSaby/XAI-fiche" target="_blank">- Cheatsheet on XAI</a>
  <a href="https://github.com/FlorianSaby/Formation-ML" target="_blank">- Deep Learning Course</a>
</div>

<script>
const canvas = document.getElementById('catCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// GitHub box safe zone
const githubBox = document.getElementById('githubBox');
function getBoxRect() {
  const padding = 140; 
  return {
    x: canvas.width - githubBox.offsetWidth - 20 - padding,
    y: canvas.height - githubBox.offsetHeight - 20 - padding,
    width: githubBox.offsetWidth + padding*2,
    height: githubBox.offsetHeight + padding*2
  };
}

// Cat setup
let cat = { x: canvas.width/2, y: canvas.height/2, angle:0 };

// Spawn mouse far from cat
function spawnMouseFarFromCat(minDistance = 700) {
  let x, y, dx, dy;
  do {
    x = Math.random() * canvas.width;
    y = Math.random() * canvas.height;
    dx = x - cat.x;
    dy = y - cat.y;
  } while (Math.hypot(dx,dy) < minDistance);
  return { x, y, vx:0, vy:0 };
}
let virtualMouse = spawnMouseFarFromCat();

// Mouse update with zigzag and strong bounce
function updateVirtualMouse(time){
  const box = getBoxRect();
  const fleeDistance = 700;  
  const personalSpace = 400; 
  const maxSpeed = 9;
  const margin = 0; // edges for bouncing

  let dx = virtualMouse.x - cat.x;
  let dy = virtualMouse.y - cat.y;
  let distance = Math.hypot(dx,dy);
  let ax=0, ay=0;

  // Flee from cat
  if(distance < fleeDistance && distance>0){
    let fleeStrength = Math.pow((fleeDistance-distance)/fleeDistance,2)*18;
    ax += (dx/distance)*fleeStrength;
    ay += (dy/distance)*fleeStrength;
  }

  // Enforce personal space
  if(distance < personalSpace && distance>0){
    ax += (dx/distance)*(personalSpace-distance)*0.6;
    ay += (dy/distance)*(personalSpace-distance)*0.6;
  }

  // Zigzag perpendicular oscillation
  if(distance>0){
    const perpX = -dy/distance;
    const perpY = dx/distance;
    const zigzagAmplitude = 4 + Math.random()*3;
    const zigzagFrequency = 0.02;
    ax += perpX * Math.sin(time*zigzagFrequency)*zigzagAmplitude;
    ay += perpY * Math.cos(time*zigzagFrequency)*zigzagAmplitude;
  }

  // GitHub box repulsion
  if(virtualMouse.x>box.x && virtualMouse.x<box.x+box.width &&
     virtualMouse.y>box.y && virtualMouse.y<box.y+box.height){
    const cx=box.x+box.width/2;
    const cy=box.y+box.height/2;
    const dxBox=virtualMouse.x-cx;
    const dyBox=virtualMouse.y-cy;
    const dist=Math.hypot(dxBox,dyBox);
    if(dist>0){ ax+=(dxBox/dist)*6; ay+=(dyBox/dist)*6; }
  }

  // Smooth velocity
  virtualMouse.vx = (virtualMouse.vx + ax)*0.94;
  virtualMouse.vy = (virtualMouse.vy + ay)*0.94;

  // Cap speed
  let speed = Math.hypot(virtualMouse.vx, virtualMouse.vy);
  if(speed>maxSpeed){ virtualMouse.vx=(virtualMouse.vx/speed)*maxSpeed; virtualMouse.vy=(virtualMouse.vy/speed)*maxSpeed; }

  // Move mouse
  virtualMouse.x += virtualMouse.vx;
  virtualMouse.y += virtualMouse.vy;

  // Strong bounce off screen edges
  if(virtualMouse.x < margin){ virtualMouse.x = margin; virtualMouse.vx *= -1.5; }
  if(virtualMouse.x > canvas.width-margin){ virtualMouse.x = canvas.width-margin; virtualMouse.vx *= -1.5; }
  if(virtualMouse.y < margin){ virtualMouse.y = margin; virtualMouse.vy *= -1.5; }
  if(virtualMouse.y > canvas.height-margin){ virtualMouse.y = canvas.height-margin; virtualMouse.vy *= -1.5; }
}

// Draw mouse
function drawVirtualMouse(){
  ctx.save();
  ctx.translate(virtualMouse.x,virtualMouse.y);
  const angle = Math.atan2(virtualMouse.vy,virtualMouse.vx);
  ctx.rotate(angle);

  ctx.fillStyle="#777";
  ctx.beginPath(); ctx.ellipse(0,0,12,8,0,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(14,0,6,0,Math.PI*2); ctx.fill();
  ctx.fillStyle="#555";
  ctx.beginPath(); ctx.moveTo(16,-4); ctx.lineTo(19,-9); ctx.lineTo(12,-6); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(16,4); ctx.lineTo(19,9); ctx.lineTo(12,6); ctx.closePath(); ctx.fill();
  ctx.strokeStyle="#555"; ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(-12,0); ctx.lineTo(-24,Math.sin(Date.now()*0.03)*5); ctx.stroke();
  ctx.restore();
}

// Draw cat
function drawCat(x,y,angle,tailAngle,earTwitch){
  ctx.save();
  ctx.translate(x,y);
  ctx.rotate(angle);

  ctx.fillStyle="#cccccc"; ctx.beginPath(); ctx.ellipse(0,0,60,35,0,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(80,0,25,0,Math.PI*2); ctx.fill();

  let headX = x + Math.cos(angle)*80;
  let headY = y + Math.sin(angle)*80;
  let dx = virtualMouse.x - headX;
  let dy = virtualMouse.y - headY;
  let eyeAngle = Math.atan2(dy,dx);
  let eyeDistance = Math.min(Math.hypot(dx,dy)/25,6);

  ctx.fillStyle="#ffffff";
  ctx.beginPath(); ctx.arc(90+Math.cos(eyeAngle)*eyeDistance,-8+Math.sin(eyeAngle)*eyeDistance,7,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(90+Math.cos(eyeAngle)*eyeDistance,8+Math.sin(eyeAngle)*eyeDistance,7,0,Math.PI*2); ctx.fill();
  ctx.fillStyle="#000000";
  ctx.beginPath(); ctx.arc(90+Math.cos(eyeAngle)*eyeDistance,-8+Math.sin(eyeAngle)*eyeDistance,3,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(90+Math.cos(eyeAngle)*eyeDistance,8+Math.sin(eyeAngle)*eyeDistance,3,0,Math.PI*2); ctx.fill();

  ctx.fillStyle="#ffcccc";
  ctx.beginPath(); ctx.moveTo(85,-12+earTwitch); ctx.lineTo(97,-30+earTwitch); ctx.lineTo(72,-16+earTwitch); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(85,12-earTwitch); ctx.lineTo(97,30-earTwitch); ctx.lineTo(72,16-earTwitch); ctx.closePath(); ctx.fill();

  ctx.strokeStyle="#ffcccc"; ctx.lineWidth=6;
  ctx.beginPath(); ctx.moveTo(-60,0); ctx.lineTo(-95,-20+tailAngle); ctx.stroke();

  ctx.restore();
}

// Animate
function animate(time){
  ctx.fillStyle="rgba(255,238,221,0.3)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  updateVirtualMouse(time);
  drawVirtualMouse();

  const box = getBoxRect();

  // Cat follows mouse but keeps separation
  let dx = virtualMouse.x - cat.x;
  let dy = virtualMouse.y - cat.y;
  let distance = Math.hypot(dx,dy);
  let minSeparation = 400;

  let speedFactor = Math.min(distance/100,2.0);
  if(distance > minSeparation){
    cat.x += dx*speedFactor*0.04;
    cat.y += dy*speedFactor*0.04;
  }

  // Avoid GitHub box
  if(cat.x>box.x && cat.x<box.x+box.width && cat.y>box.y && cat.y<box.y+box.height){
    const cx = box.x+box.width/2;
    const cy = box.y+box.height/2;
    const dxBox = cat.x-cx;
    const dyBox = cat.y-cy;
    const dist = Math.hypot(dxBox,dyBox);
    if(dist>0){ cat.x += (dxBox/dist)*10; cat.y += (dyBox/dist)*10; }
  }

  cat.angle = Math.atan2(dy,dx);
  let tailAngle = Math.sin(time*0.005)*20;
  let earTwitch = Math.cos(time*0.007)*4;
  drawCat(cat.x,cat.y,cat.angle,tailAngle,earTwitch);

  requestAnimationFrame(animate);
}

animate(0);

window.addEventListener('resize',()=>{
  canvas.width=window.innerWidth;
  canvas.height=window.innerHeight;
});
</script>
</body>
</html>
